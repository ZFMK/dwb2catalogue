# -*- coding: utf8 -*-
"""
Class to connect to database and to read its structure
Provides an object with database connector and metadata
Author: Bj√∂rn Quast b.quast@zfmk.de
CC By 4.0
"""

import pymysql
from pymysql.constants import CLIENT
import warnings
import traceback
import time
import sys
import re
import pudb
import logging

log = logging.getLogger(__name__)

from .MySQLTable import MySQLTable

class MySQLStruct():
	def __init__(self, config = None, host = None, user = None, passwd = None, db = None, charset = None, port = None):
		'''
		Class to read and represent the database structure
		'''
		if config is None:
			self.config = {
			'host': 'localhost',
			'passwd': '',
			'charset': 'utf8',
			'port': '3306',
			'user': None,
			'db': None
			}
		else: 
			self.config = config
		if host is not None:
			self.config['host'] = host
		if user is not None:
			self.config['user'] = user
		if passwd is not None:
			self.config['passwd'] = passwd
		if db is not None:
			self.config['db'] = db
		if charset is not None:
			self.config['charset'] = charset
		if port is not None:
			self.config['port'] = port
		
		
		if (self.config['db'] is None) or (self.config['user'] is None):
			raise Exception ('Not enough data base connection parameters given')
		self.con = None
		self.cur = None
		self.open_connection()
		self.MysqlError = pymysql.err

		self.databasename = self.config['db']
		self.definedtables = []
		

		'''
		read database structure
		'''
		self.tablenames = self.__readTableNames()
		# set an empty list with temptablenames in this session
		self.temptablenames = []


	def open_connection(self):
		self.con = self.__mysql_connect()
		self.cur = self.con.cursor()
		self.con.autocommit(True)


	def __mysql_connect(self):
		try:
			con = pymysql.connect(host=self.config['host'], port=int(self.config['port']), user=self.config['user'], passwd=self.config['passwd'], db=self.config['db'], charset=self.config['charset'], client_flag=CLIENT.MULTI_STATEMENTS)
		except pymysql.Error as e:
			log.critical("Error {0}: {1}".format(*e.args))
			raise
		return con


	def closeConnection(self):
		if self.con:
			self.con.close()



	'''
	expose the connection, cursor and overwritten execute method to be compatible with Peters programs
	'''
	
	def getCursor(self):
		return self.cur
	
	def getConnection(self):
		return self.con
	
	#def getExecuteMethod(self):
	#	return self.execute



	def __readTableNames(self):
		# returns a list of table names found in database, is much faster than generating all table objects here
		# table objects can be generated by __setTableByName() and __setAllTables() when they are needed
		sql_gettables = """SHOW TABLES"""
		cur = self.cur
		cur.execute(sql_gettables)
		rows = cur.fetchall()
		self.tablenames = []
		for row in rows:
			tablename = row[0]
			self.tablenames.append(tablename)
		return self.tablenames

	# self.tablenames are set by constructor calling __readTableNames, tableobjects are set on demand by __setTableByName or __setAllTables

	def __setTableByName(self, tablename):
		# generates table object from tablename
		table = MySQLTable(self, tablename)
		return table

	def __setAllTables(self):
		# fills a list with all tables as MySQLTable-objects
		self.tables = []
		for tablename in self.tablenames:
			self.tables.append(self.__setTableByName(tablename))
		return self.tables

	def getAllTables(self):
		# returns a list with all tables as MySQLTable-objects
		try:
			return self.tables
		except AttributeError:
			self.tables = self.__setAllTables()
			return self.tables

	def getTableNames(self):
		# returns a list with the names of all tables found in database
		try:
			return self.tablenames
		except AttributeError:
			self.__readTableNames()
			return self.tablenames

	def getTableByName(self, tablename):
		# look for table object in self tables or return a table-object generated by __setTableByName
		if isinstance(tablename, MySQLTable):
			return tablename
		elif isinstance(tablename, str):
			for table in self.definedtables:
				if table.tablename == tablename:
					return table
			table = self.__setTableByName(tablename)
			self.definedtables.append(table)
			# fails in MSSQLTable.readColumns() when tablename is not in database, hopefully 
			return table
		else:
			raise ValueError ('MySQLStruct.getTableNameByTable: parameter table must be a MSSQLTable object or string')
			
	def getTableNameByTable(self, table):
		if isinstance(table, MySQLTable):
			return table.tablename
		elif isinstance(table, str):
			# check that table with that name exists otherwise try to set up this table with given name
			try:
				for table in self.tables:
					if table.tablename == table:
						return table.tablename
				return None
			except AttributeError:
				table = self.__setTableByName(table)
				return table.tablename
		else:
			raise ValueError ('MySQLStruct.getTableNameByTable: parameter table must be a MySQLTable object or string')
	
	
	def getTempTableNames(self):
		return self.temptablenames

	def __addTempTableName(self, temptablename = None):
		if temptablename is not None:
			self.temptablenames.append(temptablename)
		return self

	def addTempTable(self, temptablename = None, columndicts = None):
		if temptablename is None:
			raise ValueError('MySQLTools.__addTempTable: name of temporary table must be provided as parameter temptablename')
		if columndicts is None:
			raise ValueError('MySQLTools.__addTempTable: a list of column dictionaries must be provided as parameter columns')
		
		temptable = MySQLTable(self, temptablename, createtemptableobj = True)
		temptable.setTempTableColumns(columndicts)
		self.__addTempTableName(temptablename)
		# add temptable to the list of known and defined tables
		self.definedtables.append(temptable)
		return self

	def registerTempTable(self, temptablename = None):
		"""
		Because mysql can not show existing temptables but get their definitions with describe
		the name of an existing temporary table must be provided to make the temporary table available for 
		MySQLStruct 
		"""
		if temptablename is None:
			raise ValueError('MySQLTools.registerTempTable: name of an existing temporary table must be provided as parameter temptablename')
		if temptablename not in self.temptablenames:
			self.__addTempTableName(temptablename)
		
		

	def getTableNamesSortedByForeignKeys(self, tablenames = None):
		tableobjects = self.getTablesSortedByForeignKeys(tablenames)
		tablenames = []
		for table in tableobjects:
			tablenames.append(self.getTableNameByTable(table))
		return tablenames

	def getTablesSortedByForeignKeys(self, tablenames = None):
		# get a list of table objects
		tables = []
		if tablenames is None:
			tables = self.getAllTables()
		else:
			for table in tablenames:
				tableobj = self.getTableByName(table)
				tables.append(tableobj)
		# get all tablenames from list of table objects
		tablenames = []
		for table in tables:
			tablename = self.getTableNameByTable(table)
			tablenames.append(tablename)
		sortedtablenames = []
		sortedtables = []
		remtables = []
		unresolveable = []
		num_tables = len(tables)
		# first get all tables that have no foreign key
		for tableobj in tables:
			if len(tableobj.foreignkeys) < 1:
				sortedtablenames.append(tableobj.tablename)
				sortedtables.append(tableobj)
			else:
				remtables.append(tableobj)
		
		# sort the remaining tables
		remtables.sort(key = self.getLenForeignKeys) # defined below, gets the number of foreign keys in table
		# set a counter to stop after a number of loops when dependencies can not be resolved
		counter = 0
		# TODO: check if remtables is changed instead of setting counter < num_tables * 10
		# done? the counter is set back to 0 when a the list is changed
		# Thus, the loop must be run twice times the length of the remaining tables when no more maching foreign keys are found
		while (len(remtables) > 0) and (counter < num_tables * 2):
			# get a tableobj from begin of list
			tableobj = remtables.pop(0)
			foreignkeysmatched = True
			for foreignkey in tableobj.getForeignKeys():
				# foreignkey references to a table that is in list of available tables
				if foreignkey['referenced_table'] in tablenames:
					# foreignkey references to a table that is in list of sorted tables
					if foreignkey['referenced_table'] in sortedtablenames:
						pass
					# foreignkey references to its own table
					elif foreignkey['referenced_table'] == tableobj.tablename:
						pass
					else:
						foreignkeysmatched = False
				else:
					# referenced table is not in tables at all
					unresolveable.append(foreignkey['referenced_table'])
			if foreignkeysmatched is True:
				sortedtablenames.append(tableobj.tablename)
				sortedtables.append(tableobj)
				# reset the counter
				counter = 0
			else:
				# re-add the tableobject at the end of the list 
				remtables.append(tableobj)
			counter += 1
		# re-add the remaining tables at end of the sorted list, so that they are not lost
		sortedtables.extend(remtables)
		return sortedtables
		
	def getLenForeignKeys(self, tableobj):
		'''
		This is here as helper method for sorting in getTablesSortedByForeignKeys
		just to define the key parameter to sort by
		'''
		return len(tableobj.foreignkeys)


